{% extends "base.html" %}
{% block title %}Vesper{% endblock %}
{% block head %}
<script src="https://unpkg.com/lightweight-charts@4/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
{% endblock %}
{% block body %}

<!-- Scrolling Ticker Bar -->
<div class="ticker-bar" id="tickerBar">
    <div class="ticker-track" id="tickerTrack">
        <span class="ticker-item"><span class="ticker-name">Loading prices...</span></span>
    </div>
</div>

<div class="nav">
    <span class="nav-logo">vesper</span>
    <div class="nav-links">
        <a class="nav-link active" href="/dashboard">Dashboard</a>
        <a class="nav-link" href="#" onclick="toggleLogsDrawer();return false;">Logs</a>
        <a class="nav-link" href="/settings">Settings</a>
        <a class="nav-link" href="/logout">Log out</a>
    </div>
</div>

<div class="page-wrapper">
<div class="container">

    {% if not has_api_keys %}
    <div class="alert" style="background:rgba(255,255,255,0.04);color:var(--text-secondary);border:1px solid var(--border);border-radius:12px;">
        Connect your Coinbase API keys to start trading.
        <a href="/settings" style="margin-left:8px;font-weight:600;">Setup</a>
    </div>
    {% endif %}

    <!-- Portfolio Header + Stats -->
    <div style="display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:32px;flex-wrap:wrap;gap:16px;">
        <div>
            <div style="font-size:14px;color:var(--text-muted);margin-bottom:4px;">Portfolio Value</div>
            <div style="font-size:48px;font-weight:700;letter-spacing:-2px;line-height:1;" id="portfolioValue">${{ "%.2f"|format(cash) }}</div>
            <div style="display:flex;align-items:center;gap:8px;margin-top:8px;">
                <span id="totalPnl" class="{{ 'positive' if total_pnl >= 0 else 'negative' }}" style="font-size:16px;font-weight:600;">
                    ${{ "%+.2f"|format(total_pnl) }} ({{ "%+.2f"|format(total_pnl_pct) }}%)
                </span>
                <span style="font-size:13px;color:var(--text-muted);">all time</span>
            </div>
        </div>
        <div style="display:flex;gap:24px;">
            <div style="text-align:center;">
                <div style="font-size:20px;font-weight:700;" id="statWinRate">{{ "%.0f"|format(win_rate) }}%</div>
                <div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;">Win Rate</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:20px;font-weight:700;" id="statTrades">{{ total_trades }}</div>
                <div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;">Trades</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:20px;font-weight:700;" id="statOpen">0</div>
                <div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;">Open</div>
            </div>
        </div>
    </div>

    <!-- AI Autopilot -->
    <div class="card" id="autopilotCard" style="background:linear-gradient(135deg, rgba(99,102,241,0.08), rgba(168,85,247,0.06));border:1px solid rgba(99,102,241,0.2);">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
            <div>
                <div class="card-title" style="margin-bottom:2px;display:flex;align-items:center;gap:8px;">
                    AI Autopilot
                    <span id="apStatus" style="font-size:11px;padding:2px 8px;border-radius:10px;background:var(--border);color:var(--text-muted);font-weight:600;">OFF</span>
                </div>
                <div style="font-size:12px;color:var(--text-muted);">Give Vesper a budget — AI manages entries, exits, and allocation using whale tracking + sentiment</div>
            </div>
        </div>
        <div id="apOff" style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
            <div style="position:relative;">
                <span style="position:absolute;left:10px;top:50%;transform:translateY(-50%);color:var(--text-muted);font-size:14px;">$</span>
                <input type="number" id="apAmount" placeholder="500" min="10" step="10"
                       style="padding:8px 8px 8px 24px;border:1px solid var(--border);border-radius:8px;background:var(--surface);color:var(--text);width:120px;font-size:14px;">
            </div>
            <select id="apSlots" style="padding:8px 12px;border:1px solid var(--border);border-radius:8px;background:var(--surface);color:var(--text);font-size:13px;">
                <option value="2">2 positions max</option>
                <option value="3" selected>3 positions max</option>
                <option value="5">5 positions max</option>
            </select>
            <button class="btn btn-accent" onclick="startAutopilot()">Start Autopilot</button>
        </div>
        <div id="apOn" style="display:none;">
            <div style="display:flex;gap:24px;margin-bottom:12px;flex-wrap:wrap;">
                <div>
                    <div style="font-size:24px;font-weight:700;" id="apFund">$0</div>
                    <div style="font-size:11px;color:var(--text-muted);">Total Fund</div>
                </div>
                <div>
                    <div style="font-size:24px;font-weight:700;color:var(--green);" id="apDeployed">$0</div>
                    <div style="font-size:11px;color:var(--text-muted);">Deployed</div>
                </div>
                <div>
                    <div style="font-size:24px;font-weight:700;color:var(--text-muted);" id="apAvailable">$0</div>
                    <div style="font-size:11px;color:var(--text-muted);">Available</div>
                </div>
                <div>
                    <div style="font-size:24px;font-weight:700;" id="apPositions">0/3</div>
                    <div style="font-size:11px;color:var(--text-muted);">Positions</div>
                </div>
            </div>
            <div id="apActivity" style="margin-top:12px;max-height:200px;overflow-y:auto;font-size:12px;border-top:1px solid var(--border);padding-top:10px;">
                <div style="color:var(--text-muted);font-style:italic;">Waiting for first scan...</div>
            </div>
            <div style="display:flex;gap:8px;margin-top:12px;">
                <button class="btn" style="background:var(--border);font-size:12px;padding:6px 16px;" onclick="stopAutopilot()">Stop Autopilot</button>
            </div>
        </div>
    </div>

    <!-- Real-Time Price Chart -->
    <div class="card" style="padding:0;overflow:hidden;">
        <div style="display:flex;justify-content:space-between;align-items:center;padding:16px 20px 0;flex-wrap:wrap;gap:8px;">
            <div class="chart-tabs" style="padding:0;">
                {% set symbols = user.symbols.split(',') %}
                {% for sym in symbols %}
                <button class="chart-tab {{ 'active' if loop.first }}"
                        data-symbol="{{ sym.strip() }}"
                        onclick="switchChart(this, '{{ sym.strip() }}')">
                    {{ sym.strip().split('/')[0] }}
                </button>
                {% endfor %}
            </div>
            <div class="chart-tabs" style="padding:0;">
                <button class="chart-tab" data-tf="15m" onclick="switchTimeframe(this, '15m')">15m</button>
                <button class="chart-tab active" data-tf="1h" onclick="switchTimeframe(this, '1h')">1H</button>
                <button class="chart-tab" data-tf="4h" onclick="switchTimeframe(this, '4h')">4H</button>
                <button class="chart-tab" data-tf="1d" onclick="switchTimeframe(this, '1d')">1D</button>
            </div>
        </div>
        <div id="priceChart" style="height:400px;"></div>
    </div>

    <!-- Active Bets -->
    <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <div class="card-title" style="margin-bottom:0;">Active Bets</div>
            <button class="btn btn-accent btn-sm" onclick="openTradeModal()">+ New Bet</button>
        </div>
        <div id="activeBets">
            <div class="empty-state">
                <div class="empty-state-icon">~</div>
                No active bets — pick a strategy below to start
            </div>
        </div>
    </div>

    <!-- Strategy Catalog -->
    <div class="card">
        <div class="card-title">Strategies</div>
        <div class="strategy-grid">
            {% for s in strategies %}
            <div class="strategy-card" onclick="openTradeModal('{{ s.id }}')">
                <div class="strategy-header">
                    <div>
                        <span class="strategy-icon">{{ s.icon }}</span>
                        <span class="strategy-name">{{ s.name }}</span>
                    </div>
                    <span class="risk-badge risk-{{ s.risk_level }}">{{ s.risk_level }}</span>
                </div>
                <div class="strategy-desc">{{ s.description }}</div>
                <div class="strategy-meta">
                    <div>
                        <div class="strategy-meta-label">Timeframe</div>
                        <div class="strategy-meta-value">{{ s.timeframe }}</div>
                    </div>
                    {% if s.min_return_pct > 0 or s.max_return_pct > 0 %}
                    <div>
                        <div class="strategy-meta-label">Expected</div>
                        <div class="strategy-meta-value positive">+{{ s.min_return_pct }}% to +{{ s.max_return_pct }}%</div>
                    </div>
                    {% endif %}
                    {% if s.default_stop_loss_pct > 0 %}
                    <div>
                        <div class="strategy-meta-label">Stop-Loss</div>
                        <div class="strategy-meta-value negative">-{{ s.default_stop_loss_pct }}%</div>
                    </div>
                    {% endif %}
                    <div>
                        <div class="strategy-meta-label">Mode</div>
                        <div class="strategy-meta-value">{{ s.default_mode | replace('_', ' ') | title }}</div>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- Cumulative P&L Chart -->
    <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
            <div class="card-title" style="margin-bottom:0;">Profit & Loss</div>
            <div style="display:flex;gap:12px;font-size:13px;">
                <span style="color:var(--text-muted);">Realized: <span id="pnlRealized" style="font-weight:600;">${{ "%+.2f"|format(total_pnl) }}</span></span>
                <span style="color:var(--text-muted);">Unrealized: <span id="pnlUnrealized" style="font-weight:600;">$0.00</span></span>
            </div>
        </div>
        <div style="height:220px;">
            <canvas id="pnlChart"></canvas>
        </div>
    </div>

    <!-- Trade History -->
    <div class="card">
        <div class="card-title">Trade History</div>
        {% if trades %}
        <table>
            <thead><tr>
                <th>Asset</th><th>Strategy</th><th>Entry</th><th>Exit</th>
                <th>Return</th><th>Time</th>
            </tr></thead>
            <tbody>
                {% for t in trades %}
                <tr>
                    <td style="font-weight:600;">{{ t.symbol.split('/')[0] }}</td>
                    <td style="font-size:12px;color:var(--text-secondary);">{{ t.reason }}</td>
                    <td>${{ "{:,.2f}".format(t.entry_price) }}</td>
                    <td>${{ "{:,.2f}".format(t.exit_price) }}</td>
                    <td>
                        <span class="{{ 'positive' if t.pnl_usd >= 0 else 'negative' }}" style="font-weight:600;">
                            ${{ "%+.2f"|format(t.pnl_usd) }}
                        </span>
                        <span style="color:var(--text-muted);font-size:12px;margin-left:4px;">
                            {{ "%+.1f"|format(t.pnl_pct) }}%
                        </span>
                    </td>
                    <td style="color:var(--text-muted);">{{ t.exit_time }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        {% else %}
        <div class="empty-state">
            <div class="empty-state-icon">~</div>
            No trades yet
        </div>
        {% endif %}
    </div>

</div>
</div>

<!-- Trade Modal -->
<div class="modal-overlay" id="tradeModal">
    <div class="modal">
        <button class="modal-close" onclick="closeTradeModal()">&times;</button>
        <div class="modal-title" id="modalTitle">New Bet</div>

        <div class="input-group">
            <label class="input-label">Strategy</label>
            <select class="input" id="modalStrategy" onchange="updateModalDefaults()">
                {% for s in strategies %}
                <option value="{{ s.id }}"
                        data-sl="{{ s.default_stop_loss_pct }}"
                        data-tpmin="{{ s.min_return_pct }}"
                        data-tpmax="{{ s.max_return_pct }}"
                        data-mode="{{ s.default_mode }}"
                        data-desc="{{ s.description }}">
                    {{ s.icon }} {{ s.name }} — {{ s.timeframe }}
                </option>
                {% endfor %}
            </select>
        </div>

        <!-- Strategy Callout -->
        <div class="strategy-callout" id="strategyCallout">
            <div class="strategy-callout-title">How it works</div>
            <div id="strategyCalloutText">Select a strategy to see details.</div>
        </div>

        <div class="input-group">
            <label class="input-label">Asset</label>
            <select class="input" id="modalSymbol">
                {% set symbols = user.symbols.split(',') %}
                {% for sym in symbols %}
                <option value="{{ sym.strip() }}">{{ sym.strip() }}</option>
                {% endfor %}
            </select>
            <!-- AI Signal Badge -->
            <div id="signalBadge" style="margin-top:8px;padding:10px 14px;border-radius:8px;font-size:13px;display:none;border:1px solid var(--border);">
                <span id="signalIcon"></span>
                <span id="signalText" style="font-weight:600;"></span>
                <span id="signalConfidence" style="margin-left:4px;"></span>
                <div id="signalReason" style="color:var(--text-secondary);margin-top:4px;font-size:12px;"></div>
            </div>
        </div>

        <!-- Paper / Real Toggle -->
        <div class="input-group">
            <label class="input-label">Trade Type</label>
            <div class="mode-toggle">
                <button type="button" class="mode-toggle-btn active" id="modePaper"
                        onclick="setTradeMode('paper')">Paper</button>
                <button type="button" class="mode-toggle-btn" id="modeReal"
                        onclick="setTradeMode('real')">Real</button>
            </div>
        </div>

        <!-- One-Off / Continuous Toggle -->
        <div class="input-group">
            <label class="input-label">Bet Mode</label>
            <div class="mode-toggle">
                <button type="button" class="mode-toggle-btn active" id="modeOneOff"
                        onclick="setBetMode('one_off')">One-Off</button>
                <button type="button" class="mode-toggle-btn" id="modeContinuous"
                        onclick="setBetMode('continuous')">Continuous</button>
            </div>
        </div>

        <div class="input-group">
            <label class="input-label">Position Size ($)</label>
            <input type="number" class="input" id="modalAmount" value="50" min="1" step="1">
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;">
            <div class="input-group">
                <label class="input-label tooltip-wrap">
                    Stop-Loss %
                    <span class="tooltip-icon">?</span>
                    <span class="tooltip-text">If the price drops by this %, your position auto-closes to limit losses.</span>
                </label>
                <input type="number" class="input" id="modalSL" value="2" min="0.1" step="0.1">
            </div>
            <div class="input-group">
                <label class="input-label tooltip-wrap">
                    TP Min %
                    <span class="tooltip-icon">?</span>
                    <span class="tooltip-text">Minimum take-profit target. The bot may start closing here for partial gains.</span>
                </label>
                <input type="number" class="input" id="modalTPMin" value="1.5" min="0.1" step="0.1">
            </div>
            <div class="input-group">
                <label class="input-label tooltip-wrap">
                    TP Max %
                    <span class="tooltip-icon">?</span>
                    <span class="tooltip-text">Maximum take-profit. Position auto-closes when the price reaches this gain.</span>
                </label>
                <input type="number" class="input" id="modalTPMax" value="5" min="0.1" step="0.1">
            </div>
        </div>

        <div style="display:flex;align-items:center;gap:12px;margin-top:8px;">
            <label class="input-label tooltip-wrap" style="display:flex;align-items:center;gap:8px;cursor:pointer;margin:0;">
                <input type="checkbox" id="modalTrailing" onchange="toggleTrailing()" style="width:16px;height:16px;">
                <span>Trailing Stop</span>
                <span class="tooltip-icon">?</span>
                <span class="tooltip-text">Instead of closing at a fixed profit target, the stop-loss follows the price up. Locks in gains while letting winners run indefinitely.</span>
            </label>
            <input type="number" class="input" id="modalTrailingPct" value="3" min="0.5" step="0.5"
                   style="width:80px;display:none;" placeholder="%">
            <span id="trailingLabel" style="display:none;font-size:12px;color:var(--text-muted);">trail %</span>
        </div>

        <div style="display:flex; justify-content:space-between; padding:10px 0; margin-top:4px; border-top:1px solid #222;">
            <span style="color:var(--red); font-weight:600;" id="maxLossDisplay">Max Loss: -$1.00</span>
            <span style="color:var(--text-muted); font-weight:600;" id="feeDisplay">Fee: ~$0.30</span>
            <span style="color:var(--green); font-weight:600;" id="maxWinDisplay">Max Win: +$2.50</span>
        </div>

        <div id="modalError" class="alert alert-error" style="display:none;"></div>
        <div id="modalSuccess" class="alert alert-success" style="display:none;"></div>

        <button class="btn btn-accent btn-full" id="placeBetBtn" onclick="placeBet()" style="margin-top:8px;">
            Place Bet
        </button>
    </div>
</div>

<script>
// ═══════════════════════════════════════
// State
// ═══════════════════════════════════════
let currentSymbol = '{{ user.symbols.split(",")[0].strip() }}';
let currentTimeframe = '1h';
let currentBetMode = 'one_off';
let currentTradeMode = 'paper';
let chart, candleSeries;
// Track previous P&L values for flash animations
let prevPnlMap = {};
// Track known position IDs for detecting new cards
let knownPositionIds = new Set();

// ═══════════════════════════════════════
// Ticker Bar (refresh every 5s)
// ═══════════════════════════════════════
async function updateTicker() {
    try {
        const resp = await fetch('/api/ticker');
        if (!resp.ok) return;
        const data = await resp.json();
        const track = document.getElementById('tickerTrack');
        let html = '';
        data.forEach(d => {
            const cls = d.change_pct >= 0 ? 'positive' : 'negative';
            const arrow = d.change_pct >= 0 ? '\u25B2' : '\u25BC';
            const price = d.price >= 1 ? d.price.toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2}) : d.price.toFixed(4);
            html += `<span class="ticker-item">
                <span class="ticker-name">${d.name}</span>
                <span class="ticker-price">$${price}</span>
                <span class="ticker-change ${cls}">${arrow} ${d.change_pct.toFixed(2)}%</span>
            </span>`;
        });
        // Duplicate for seamless loop
        track.innerHTML = html + html;
    } catch(e) {}
}
updateTicker();
setInterval(updateTicker, 5000);

// ═══════════════════════════════════════
// Price Chart (TradingView Lightweight, refresh every 10s)
// ═══════════════════════════════════════
function initChart() {
    const container = document.getElementById('priceChart');
    chart = LightweightCharts.createChart(container, {
        layout: { background: { color: '#111111' }, textColor: '#9ca3af' },
        grid: { vertLines: { color: '#1a1a1a' }, horzLines: { color: '#1a1a1a' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderColor: '#1a1a1a' },
        timeScale: { borderColor: '#1a1a1a', timeVisible: true },
        width: container.clientWidth,
        height: 400,
    });
    candleSeries = chart.addCandlestickSeries({
        upColor: '#00dc5a', downColor: '#ff3b30',
        borderUpColor: '#00dc5a', borderDownColor: '#ff3b30',
        wickUpColor: '#00dc5a', wickDownColor: '#ff3b30',
    });
    // Responsive
    new ResizeObserver(() => {
        chart.applyOptions({ width: container.clientWidth });
    }).observe(container);
}

async function loadChart(symbol, timeframe) {
    try {
        const safeSym = symbol.replace('/', '-');
        const resp = await fetch(`/api/chart/${safeSym}?timeframe=${timeframe}`);
        if (!resp.ok) return;
        const data = await resp.json();
        if (data.length > 0) {
            candleSeries.setData(data);
            chart.timeScale().fitContent();
        }
    } catch(e) {}
}

function switchChart(btn, symbol) {
    document.querySelectorAll('.chart-tab[data-symbol]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentSymbol = symbol;
    loadChart(symbol, currentTimeframe);
}

function switchTimeframe(btn, tf) {
    document.querySelectorAll('.chart-tab[data-tf]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentTimeframe = tf;
    loadChart(currentSymbol, tf);
}

initChart();
loadChart(currentSymbol, currentTimeframe);
// Refresh chart every 10s
setInterval(() => loadChart(currentSymbol, currentTimeframe), 10000);

// ═══════════════════════════════════════
// Active Bets — Full Dynamic Rendering (every 3s)
// ═══════════════════════════════════════
function formatPrice(price) {
    if (price >= 1) return price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
    return price.toFixed(4);
}

function renderBetCard(p, isNew) {
    const pnlCls = p.pnl_usd >= 0 ? 'positive' : 'negative';
    const pnlSign = p.pnl_usd >= 0 ? '+' : '';
    const pctSign = p.pnl_pct >= 0 ? '+' : '';
    const rr = p.max_loss > 0 ? (p.max_win / p.max_loss) : 0;
    const rrCls = rr >= 2 ? 'positive' : rr >= 1 ? 'neutral' : 'negative';
    const progressPct = Math.max(0, Math.min(100, p.progress));
    const progressColor = p.pnl_usd >= 0 ? 'var(--green)' : 'var(--red)';
    const betMode = p.bet_mode || 'one_off';
    const tradeMode = p.trade_mode || 'paper';
    const modeCls = betMode === 'continuous' ? 'continuous' : 'one_off';
    const hasTrailing = p.trailing_stop_pct > 0;

    // Flash animation class
    let flashClass = '';
    const prevPnl = prevPnlMap[p.id];
    if (prevPnl !== undefined && prevPnl !== p.pnl_usd) {
        flashClass = p.pnl_usd > prevPnl ? 'pnl-flash-positive' : 'pnl-flash-negative';
    }

    const entryDate = p.entry_time ? new Date(p.entry_time * 1000).toLocaleDateString('en', {month:'2-digit', day:'2-digit'}) + ' ' + new Date(p.entry_time * 1000).toLocaleTimeString('en', {hour:'2-digit', minute:'2-digit', hour12:false}) : '';

    // SL/TP row: show trailing info when active
    let slTpRow;
    if (hasTrailing) {
        slTpRow = `<div style="display:flex;justify-content:space-between;font-size:11px;margin-top:4px;">
            <span style="color:var(--text-muted);">SL $${formatPrice(p.stop_loss)}</span>
            <span style="color:var(--accent);font-weight:600;">Trailing ${p.trailing_stop_pct}% &mdash; SL $${formatPrice(p.trailing_sl_price)} (peak $${formatPrice(p.highest_price_seen)})</span>
        </div>`;
    } else {
        slTpRow = `<div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text-muted);margin-top:4px;">
            <span>SL $${formatPrice(p.stop_loss)}</span>
            <span>TP $${formatPrice(p.tp_min)} &ndash; $${formatPrice(p.tp_max)}</span>
        </div>`;
    }

    // Max win display
    const maxWinHtml = hasTrailing
        ? '<span style="font-size:14px;">&#8734;</span> Unlimited'
        : `+$${p.max_win.toFixed(2)}`;

    // Strategy badge
    const stratLabel = p.strategy_id ? p.strategy_id.replace('_', ' ') : '';

    return `<div class="bet-card ${isNew ? 'new-card' : ''} ${flashClass}" data-pid="${p.id}">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;">
            <div>
                <div style="font-size:16px;font-weight:700;">${p.name || p.symbol.split('/')[0]}</div>
                <div style="display:flex;gap:6px;margin-top:4px;">
                    <span class="mode-badge mode-${modeCls}">${betMode.replace('_', ' ')}</span>
                    <span class="mode-badge trade-mode-${tradeMode}">${tradeMode}</span>
                    ${hasTrailing ? '<span class="mode-badge" style="background:rgba(0,180,255,0.15);color:#0af;border-color:rgba(0,180,255,0.3);">trailing</span>' : ''}
                    ${stratLabel ? '<span class="mode-badge" style="background:rgba(255,255,255,0.04);color:var(--text-muted);border-color:var(--border);">' + stratLabel + '</span>' : ''}
                </div>
            </div>
            <div style="text-align:right;">
                <div class="bet-pnl ${pnlCls}">$${pnlSign}${p.pnl_usd.toFixed(2)}</div>
                <div style="font-size:12px;color:var(--text-muted);">${pctSign}${p.pnl_pct.toFixed(2)}%</div>
            </div>
        </div>
        <!-- Current Price (live) -->
        <div style="margin-top:8px;display:flex;align-items:center;gap:8px;">
            <span class="bet-current-price"><span class="live-dot"></span> Now $${formatPrice(p.current_price)}</span>
            <span style="font-size:12px;color:var(--text-muted);">${p.current_price >= p.entry_price ? '\u25B2' : '\u25BC'} ${Math.abs(p.pnl_pct).toFixed(2)}% from entry</span>
        </div>
        <!-- P/L View -->
        <div class="bet-pl-row">
            <div class="bet-pl-item">
                <span class="bet-pl-label">Max Loss</span>
                <span class="bet-pl-value" style="color:var(--red);">-$${p.max_loss.toFixed(2)}</span>
            </div>
            <div class="bet-pl-item">
                <span class="bet-pl-label">Fee</span>
                <span class="bet-pl-value" style="color:var(--text-muted);">~$${(p.est_fee || 0).toFixed(2)}</span>
            </div>
            <div class="bet-pl-item">
                <span class="bet-pl-label">Max Win</span>
                <span class="bet-pl-value" style="color:var(--green);">${maxWinHtml}</span>
            </div>
            <div class="bet-pl-item">
                <span class="bet-pl-label">R:R</span>
                <span class="bet-pl-value bet-rr ${rrCls}">${hasTrailing ? '&#8734;' : '1:' + rr.toFixed(1)}</span>
            </div>
        </div>
        <div style="display:flex;gap:16px;margin-top:8px;font-size:13px;color:var(--text-secondary);">
            <span>Entry $${formatPrice(p.entry_price)}</span>
            <span>Size $${p.cost_usd.toFixed(2)}</span>
            <span style="color:var(--text-muted);">${entryDate}</span>
        </div>
        <div class="bet-progress">
            <div class="bet-progress-fill" style="width:${progressPct}%;background:${progressColor};"></div>
        </div>
        ${slTpRow}
        <!-- AI Reasoning Panel -->
        <div class="reasoning-panel" id="reasoning-${p.id}" style="margin-top:10px;padding:10px;background:rgba(255,255,255,0.02);border:1px solid var(--border);border-radius:8px;font-size:12px;">
            <div style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;" onclick="toggleReasoning('${p.id}')">
                <span style="font-weight:600;color:var(--text-secondary);">AI Reasoning</span>
                <span id="reasoning-status-${p.id}" style="color:var(--text-muted);font-size:11px;">Click to load</span>
            </div>
            <div id="reasoning-body-${p.id}" style="display:none;margin-top:8px;"></div>
        </div>
        <button class="btn btn-outline btn-sm" style="width:100%;margin-top:12px;"
                onclick="closeTrade('${p.id}')">Close Position</button>
    </div>`;
}

async function updatePositions() {
    try {
        const resp = await fetch('/api/positions');
        if (!resp.ok) return;
        const positions = await resp.json();
        const container = document.getElementById('activeBets');

        if (positions.length === 0) {
            container.innerHTML = `<div class="empty-state">
                <div class="empty-state-icon">~</div>
                No active bets — pick a strategy below to start
            </div>`;
            knownPositionIds.clear();
            prevPnlMap = {};
            return;
        }

        // Build new position ID set
        const newIds = new Set(positions.map(p => p.id));

        // Render all cards
        let html = '<div class="bet-grid">';
        positions.forEach(p => {
            const isNew = !knownPositionIds.has(p.id);
            html += renderBetCard(p, isNew);
        });
        html += '</div>';
        container.innerHTML = html;

        // Update tracking state
        positions.forEach(p => { prevPnlMap[p.id] = p.pnl_usd; });
        // Clean up removed positions from prevPnlMap
        Object.keys(prevPnlMap).forEach(id => {
            if (!newIds.has(id)) delete prevPnlMap[id];
        });
        knownPositionIds = newIds;
    } catch(e) {}
}
updatePositions();
setInterval(updatePositions, 3000);

// ═══════════════════════════════════════
// Trade Modal
// ═══════════════════════════════════════
function openTradeModal(strategyId) {
    document.getElementById('tradeModal').classList.add('active');
    document.getElementById('modalError').style.display = 'none';
    document.getElementById('modalSuccess').style.display = 'none';
    if (strategyId) {
        document.getElementById('modalStrategy').value = strategyId;
    }
    updateModalDefaults();
    updateMaxWinLoss();
    fetchSignal();
}

function closeTradeModal() {
    document.getElementById('tradeModal').classList.remove('active');
}

function updateModalDefaults() {
    const sel = document.getElementById('modalStrategy');
    const opt = sel.options[sel.selectedIndex];
    document.getElementById('modalSL').value = opt.dataset.sl || 2;
    document.getElementById('modalTPMin').value = opt.dataset.tpmin || 1.5;
    document.getElementById('modalTPMax').value = opt.dataset.tpmax || 5;
    const mode = opt.dataset.mode || 'one_off';
    setBetMode(mode);
    // Update strategy callout
    const desc = opt.dataset.desc || '';
    document.getElementById('strategyCalloutText').textContent = desc || 'Select a strategy to see details.';
    updateMaxWinLoss();
}

// Set initial callout on page load
(function() {
    const sel = document.getElementById('modalStrategy');
    if (sel && sel.options.length > 0) {
        const opt = sel.options[sel.selectedIndex];
        document.getElementById('strategyCalloutText').textContent = opt.dataset.desc || '';
    }
})();

// ═══════════════════════════════════════
// AI Signal Prediction
// ═══════════════════════════════════════
async function fetchSignal() {
    const badge = document.getElementById('signalBadge');
    const sym = document.getElementById('modalSymbol').value;
    if (!sym) { badge.style.display = 'none'; return; }

    // Show loading state
    badge.style.display = 'block';
    badge.style.background = 'rgba(255,255,255,0.03)';
    badge.style.borderColor = 'var(--border)';
    document.getElementById('signalIcon').textContent = '';
    document.getElementById('signalText').textContent = 'Analyzing...';
    document.getElementById('signalText').style.color = 'var(--text-secondary)';
    document.getElementById('signalConfidence').textContent = '';
    document.getElementById('signalReason').textContent = '';

    try {
        const safeSym = sym.replace('/', '-');
        const strategyId = document.getElementById('modalStrategy').value || 'smart_auto';
        const resp = await fetch('/api/signal/' + safeSym + '?strategy=' + strategyId);
        if (!resp.ok) { badge.style.display = 'none'; return; }
        const data = await resp.json();

        const sig = data.signal || 'HOLD';
        const conf = Math.round((data.confidence || 0) * 100);
        const reason = data.reason || '';

        if (sig === 'BUY') {
            badge.style.background = 'rgba(0,220,90,0.08)';
            badge.style.borderColor = 'rgba(0,220,90,0.3)';
            document.getElementById('signalIcon').textContent = '\u25B2';
            document.getElementById('signalText').textContent = 'BUY';
            document.getElementById('signalText').style.color = 'var(--green)';
        } else if (sig === 'SELL') {
            badge.style.background = 'rgba(255,59,48,0.08)';
            badge.style.borderColor = 'rgba(255,59,48,0.3)';
            document.getElementById('signalIcon').textContent = '\u25BC';
            document.getElementById('signalText').textContent = 'SELL';
            document.getElementById('signalText').style.color = 'var(--red)';
        } else {
            badge.style.background = 'rgba(255,255,255,0.03)';
            badge.style.borderColor = 'var(--border)';
            document.getElementById('signalIcon').textContent = '\u25CF';
            document.getElementById('signalText').textContent = 'HOLD';
            document.getElementById('signalText').style.color = 'var(--text-secondary)';
        }
        document.getElementById('signalConfidence').textContent = conf > 0 ? ' \u2014 ' + conf + '% confidence' : '';
        document.getElementById('signalReason').textContent = reason;
    } catch(e) {
        badge.style.display = 'none';
    }
}

// Fetch signal when asset or strategy changes
document.getElementById('modalSymbol').addEventListener('change', fetchSignal);
document.getElementById('modalStrategy').addEventListener('change', fetchSignal);

function toggleTrailing() {
    const checked = document.getElementById('modalTrailing').checked;
    document.getElementById('modalTrailingPct').style.display = checked ? 'block' : 'none';
    document.getElementById('trailingLabel').style.display = checked ? 'inline' : 'none';
    document.getElementById('modalTPMax').disabled = checked;
    document.getElementById('modalTPMax').style.opacity = checked ? '0.3' : '1';
    updateMaxWinLoss();
}

function updateMaxWinLoss() {
    const amount = parseFloat(document.getElementById('modalAmount').value) || 0;
    const sl = parseFloat(document.getElementById('modalSL').value) || 0;
    const tpMax = parseFloat(document.getElementById('modalTPMax').value) || 0;
    const trailing = document.getElementById('modalTrailing').checked;
    // Coinbase Advanced taker fee: ~0.60% per trade (entry + exit = ~1.2% round-trip)
    const feeRate = 0.006;
    const totalFee = amount * feeRate * 2;
    // Net forecasts: factor in round-trip fees
    const maxLoss = amount * (sl / 100) + totalFee;
    document.getElementById('maxLossDisplay').textContent = 'Max Loss: -$' + maxLoss.toFixed(2);
    document.getElementById('feeDisplay').textContent = 'Fee: ~$' + totalFee.toFixed(2);
    if (trailing) {
        document.getElementById('maxWinDisplay').innerHTML = '<span style="font-size:18px;">&#8734;</span> Unlimited';
    } else {
        const maxWin = Math.max(0, amount * (tpMax / 100) - totalFee);
        document.getElementById('maxWinDisplay').textContent = 'Net Win: +$' + maxWin.toFixed(2);
    }
}

['modalAmount', 'modalSL', 'modalTPMax', 'modalTrailingPct'].forEach(id => {
    document.getElementById(id).addEventListener('input', updateMaxWinLoss);
});

function setTradeMode(mode) {
    currentTradeMode = mode;
    document.getElementById('modePaper').classList.toggle('active', mode === 'paper');
    document.getElementById('modeReal').classList.toggle('active', mode === 'real');
}

function setBetMode(mode) {
    currentBetMode = mode;
    document.getElementById('modeOneOff').classList.toggle('active', mode === 'one_off');
    document.getElementById('modeContinuous').classList.toggle('active', mode === 'continuous');
}

async function placeBet() {
    const btn = document.getElementById('placeBetBtn');
    const errEl = document.getElementById('modalError');
    const okEl = document.getElementById('modalSuccess');
    errEl.style.display = 'none';
    okEl.style.display = 'none';
    btn.disabled = true;
    btn.textContent = 'Placing...';

    try {
        const resp = await fetch('/api/open-trade', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                symbol: document.getElementById('modalSymbol').value,
                strategy_id: document.getElementById('modalStrategy').value,
                amount_usd: parseFloat(document.getElementById('modalAmount').value),
                stop_loss_pct: parseFloat(document.getElementById('modalSL').value),
                tp_min_pct: parseFloat(document.getElementById('modalTPMin').value),
                tp_max_pct: parseFloat(document.getElementById('modalTPMax').value),
                trailing_stop_pct: document.getElementById('modalTrailing').checked
                    ? parseFloat(document.getElementById('modalTrailingPct').value) || 0
                    : 0,
                bet_mode: currentBetMode,
                trade_mode: currentTradeMode,
            }),
        });
        const data = await resp.json();
        if (data.ok) {
            okEl.textContent = `Bet placed at $${data.entry_price.toLocaleString()}`;
            okEl.style.display = 'block';
            // Immediately refresh positions & portfolio — no page reload needed
            updatePositions();
            updatePortfolioStats();
            setTimeout(closeTradeModal, 1200);
        } else {
            errEl.textContent = data.error || 'Failed to place bet';
            errEl.style.display = 'block';
        }
    } catch(e) {
        errEl.textContent = 'Network error';
        errEl.style.display = 'block';
    }
    btn.disabled = false;
    btn.textContent = 'Place Bet';
}

async function closeTrade(positionId) {
    if (!confirm('Close this position at market price?')) return;
    try {
        const resp = await fetch('/api/close-trade', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ position_id: positionId }),
        });
        const data = await resp.json();
        if (data.ok) {
            // Immediately refresh — no page reload needed
            updatePositions();
            updatePortfolioStats();
        } else {
            alert(data.error || 'Failed to close');
        }
    } catch(e) {
        alert('Network error');
    }
}

// ═══════════════════════════════════════
// AI Reasoning for Open Positions
// ═══════════════════════════════════════
const reasoningLoaded = {};
const reasoningAutoRefresh = {};

function toggleReasoning(posId) {
    const body = document.getElementById('reasoning-body-' + posId);
    if (!body) return;
    const isVisible = body.style.display !== 'none';
    body.style.display = isVisible ? 'none' : 'block';
    if (!isVisible && !reasoningLoaded[posId]) {
        fetchReasoning(posId);
    }
}

async function fetchReasoning(posId) {
    const status = document.getElementById('reasoning-status-' + posId);
    const body = document.getElementById('reasoning-body-' + posId);
    if (!status || !body) return;

    status.textContent = 'Analyzing...';
    status.style.color = 'var(--accent)';

    try {
        const resp = await fetch('/api/reasoning?pid=' + encodeURIComponent(posId));
        if (!resp.ok) {
            status.textContent = 'Error';
            status.style.color = 'var(--red)';
            return;
        }
        const data = await resp.json();
        reasoningLoaded[posId] = true;

        // Action badge color
        const actionColors = { HOLD: '#0af', CAUTION: '#f80', SELL: 'var(--red)' };
        const actionColor = actionColors[data.action] || 'var(--text-muted)';
        status.innerHTML = `<span style="color:${actionColor};font-weight:600;">${data.action || 'HOLD'}</span>`;

        // Build reasoning body
        let html = `<div style="color:var(--text-secondary);margin-bottom:6px;">${data.summary || ''}</div>`;
        if (data.details && data.details.length > 0) {
            html += '<div style="display:flex;flex-direction:column;gap:3px;">';
            data.details.forEach(d => {
                html += `<div style="color:var(--text-muted);font-size:11px;padding:2px 0;border-bottom:1px solid rgba(255,255,255,0.03);">${d}</div>`;
            });
            html += '</div>';
        }
        html += `<div style="margin-top:6px;font-size:10px;color:var(--text-muted);">Auto-refreshes every 60s &mdash; <a href="#" onclick="fetchReasoning('${posId}');return false;" style="color:var(--accent);">Refresh now</a></div>`;
        body.innerHTML = html;
        body.style.display = 'block';

        // Auto-refresh every 60s while panel is open
        if (reasoningAutoRefresh[posId]) clearInterval(reasoningAutoRefresh[posId]);
        reasoningAutoRefresh[posId] = setInterval(() => {
            const el = document.getElementById('reasoning-body-' + posId);
            if (el && el.style.display !== 'none') {
                fetchReasoning(posId);
            } else {
                clearInterval(reasoningAutoRefresh[posId]);
                delete reasoningAutoRefresh[posId];
            }
        }, 60000);

    } catch(e) {
        status.textContent = 'Failed';
        status.style.color = 'var(--red)';
    }
}

// Close modal on overlay click
document.getElementById('tradeModal').addEventListener('click', function(e) {
    if (e.target === this) closeTradeModal();
});

// ═══════════════════════════════════════
// Live Portfolio Stats + P&L Chart (every 5s)
// ═══════════════════════════════════════
let pnlChart = null;

function formatPnlLabels(history) {
    const times = history.filter(d => d.time).map(d => d.time);
    if (times.length < 2) {
        return history.map(d => d.time ? new Date(d.time * 1000).toLocaleTimeString('en', {hour:'2-digit', minute:'2-digit', hour12:false}) : '');
    }
    const minT = Math.min(...times);
    const maxT = Math.max(...times);
    const spanHours = (maxT - minT) / 3600;

    if (spanHours < 24) {
        // Same day: show HH:MM
        return history.map(d => d.time ? new Date(d.time * 1000).toLocaleTimeString('en', {hour:'2-digit', minute:'2-digit', hour12:false}) : '');
    } else if (spanHours < 72) {
        // 1-3 days: show "Feb 27 14:00"
        return history.map(d => d.time ? new Date(d.time * 1000).toLocaleDateString('en', {month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', hour12:false}) : '');
    } else {
        // Multi-day: show "Feb 27"
        return history.map(d => d.time ? new Date(d.time * 1000).toLocaleDateString('en', {month:'short', day:'numeric'}) : '');
    }
}

function initPnlChart(history) {
    const ctx = document.getElementById('pnlChart');
    const labels = formatPnlLabels(history);
    const values = history.map(d => d.pnl);
    const lastVal = values.length > 0 ? values[values.length - 1] : 0;
    const positive = lastVal >= 0;

    // Bar colors: green for cumulative profit, red when dipping below zero
    const barColors = values.map(v => v >= 0 ? 'rgba(0,220,90,0.7)' : 'rgba(255,59,48,0.7)');

    // Store raw timestamps for tooltip
    const rawTimes = history.map(d => d.time || 0);

    pnlChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: barColors,
                borderRadius: 3,
                barPercentage: 0.8,
                rawTimes: rawTimes,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    mode: 'index', intersect: false,
                    backgroundColor: '#1a1a1a', borderColor: '#2a2a2a', borderWidth: 1,
                    titleColor: '#9ca3af', bodyColor: '#fff', bodyFont: { weight: '600' },
                    padding: 12, cornerRadius: 8,
                    callbacks: {
                        title: tooltipItems => {
                            const idx = tooltipItems[0].dataIndex;
                            const t = rawTimes[idx];
                            if (!t) return '';
                            return new Date(t * 1000).toLocaleString('en', {month:'short', day:'numeric', hour:'2-digit', minute:'2-digit', hour12:false});
                        },
                        label: ctx => '$' + ctx.parsed.y.toFixed(2) + ' cumulative P&L'
                    }
                }
            },
            scales: {
                x: { display: true, ticks: { color: '#555', font: { size: 10 } }, grid: { display: false } },
                y: {
                    display: true,
                    ticks: { color: '#555', font: { size: 10 }, callback: v => '$' + v },
                    grid: { color: '#1a1a1a' },
                }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
        }
    });
}

function updatePnlChart(history) {
    if (!pnlChart) {
        initPnlChart(history);
        return;
    }
    pnlChart.data.labels = formatPnlLabels(history);
    pnlChart.data.datasets[0].data = history.map(d => d.pnl);
    pnlChart.data.datasets[0].backgroundColor = history.map(d => d.pnl >= 0 ? 'rgba(0,220,90,0.7)' : 'rgba(255,59,48,0.7)');
    pnlChart.update('none');
}

async function updatePortfolioStats() {
    try {
        const resp = await fetch('/api/portfolio-stats');
        if (!resp.ok) return;
        const s = await resp.json();

        // Portfolio value (cash + positions + unrealized P&L)
        document.getElementById('portfolioValue').textContent = '$' + s.portfolio_value.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});

        // Total P&L
        const pnlEl = document.getElementById('totalPnl');
        const sign = s.total_pnl >= 0 ? '+' : '';
        pnlEl.textContent = '$' + sign + s.total_pnl.toFixed(2) + ' (' + sign + s.total_pnl_pct.toFixed(2) + '%)';
        pnlEl.className = s.total_pnl >= 0 ? 'positive' : 'negative';

        // Stats
        document.getElementById('statWinRate').textContent = Math.round(s.win_rate) + '%';
        document.getElementById('statTrades').textContent = s.total_trades;
        document.getElementById('statOpen').textContent = s.open_count;

        // P&L breakdown
        const rSign = s.realized_pnl >= 0 ? '+' : '';
        const uSign = s.unrealized_pnl >= 0 ? '+' : '';
        document.getElementById('pnlRealized').textContent = '$' + rSign + s.realized_pnl.toFixed(2);
        document.getElementById('pnlRealized').style.color = s.realized_pnl >= 0 ? 'var(--green)' : 'var(--red)';
        document.getElementById('pnlUnrealized').textContent = '$' + uSign + s.unrealized_pnl.toFixed(2);
        document.getElementById('pnlUnrealized').style.color = s.unrealized_pnl >= 0 ? 'var(--green)' : 'var(--red)';

        // P&L chart
        if (s.pnl_history && s.pnl_history.length > 0) {
            updatePnlChart(s.pnl_history);
        }
    } catch(e) {}
}

// Initialize P&L chart from server-rendered data, then switch to live
const initialPnlData = {{ equity_curve|safe }};
if (initialPnlData.length > 1) {
    // Convert equity curve to cumulative P&L format
    const initial = initialPnlData[0].value;
    const pnlHistory = initialPnlData.slice(1).map(d => ({
        time: d.time,
        pnl: +(d.value - initial).toFixed(2),
    }));
    initPnlChart(pnlHistory);
} else {
    initPnlChart([]);
}

// Fetch live stats immediately and every 5s
updatePortfolioStats();
setInterval(updatePortfolioStats, 5000);

// ═══════════════════════════════════════
// Autopilot
// ═══════════════════════════════════════

function renderApLog(log) {
    if (!log || log.length === 0) return '<div style="color:var(--text-muted);font-style:italic;">Waiting for first scan...</div>';
    // Show most recent first
    const entries = [...log].reverse();
    return entries.map(e => {
        const t = e.time ? new Date(e.time * 1000).toLocaleTimeString('en', {hour:'2-digit', minute:'2-digit', hour12:false}) : '';
        const scanned = e.symbols_scanned || 0;

        if (e.status === 'fully_deployed') {
            return `<div style="padding:4px 0;border-bottom:1px solid var(--border);">
                <span style="color:var(--text-muted);">${t}</span>
                <span style="color:var(--accent);font-weight:600;"> All slots filled</span>
                <span style="color:var(--text-muted);"> — ${e.positions}/${e.max_positions} positions, $${e.deployed_usd} deployed</span>
            </div>`;
        }
        if (e.status === 'low_funds') {
            return `<div style="padding:4px 0;border-bottom:1px solid var(--border);">
                <span style="color:var(--text-muted);">${t}</span>
                <span style="color:var(--yellow,#f59e0b);font-weight:600;"> Low funds</span>
                <span style="color:var(--text-muted);"> — $${e.available_usd} available</span>
            </div>`;
        }

        // Actions taken
        let actionsHtml = '';
        if (e.actions && e.actions.length > 0) {
            actionsHtml = e.actions.map(a =>
                `<div style="padding:2px 0 2px 12px;color:var(--green);font-weight:600;">
                    BUY ${a.symbol} — $${a.amount_usd} @ $${a.price.toLocaleString()} (${(a.confidence*100).toFixed(0)}% conf, whale: ${a.whale > 0 ? '+' : ''}${a.whale}, sentiment: ${a.sentiment > 0 ? '+' : ''}${a.sentiment})
                </div>
                <div style="padding:0 0 2px 12px;color:var(--text-muted);font-size:11px;">${a.reason}</div>`
            ).join('');
        }

        // Top signals
        let topHtml = '';
        if (e.top_signals && e.top_signals.length > 0 && !e.actions?.length) {
            topHtml = '<div style="padding:2px 0 2px 12px;color:var(--text-muted);">Top signals: ' +
                e.top_signals.slice(0, 3).map(s =>
                    `${s.symbol} ${s.signal} ${(s.confidence*100).toFixed(0)}%`
                ).join(', ') + '</div>';
        }

        const statusIcon = e.actions?.length > 0 ? '🟢' : '⏳';
        const statusText = e.actions?.length > 0
            ? `Opened ${e.actions.length} position${e.actions.length > 1 ? 's' : ''}`
            : `Scanned ${scanned} symbols — no opportunity`;

        return `<div style="padding:4px 0;border-bottom:1px solid var(--border);">
            <span style="color:var(--text-muted);">${t}</span>
            <span style="font-weight:600;${e.actions?.length > 0 ? 'color:var(--green);' : ''}"> ${statusText}</span>
            ${actionsHtml}${topHtml}
        </div>`;
    }).join('');
}

async function fetchAutopilotStatus() {
    try {
        const resp = await fetch('/api/autopilot');
        if (!resp.ok) return;
        const ap = await resp.json();
        const statusEl = document.getElementById('apStatus');
        const onEl = document.getElementById('apOn');
        const offEl = document.getElementById('apOff');

        if (ap.enabled) {
            statusEl.textContent = 'ACTIVE';
            statusEl.style.background = 'var(--green)';
            statusEl.style.color = '#000';
            onEl.style.display = 'block';
            offEl.style.display = 'none';
            document.getElementById('apFund').textContent = '$' + ap.fund_usd.toFixed(0);
            document.getElementById('apDeployed').textContent = '$' + ap.deployed_usd.toFixed(0);
            document.getElementById('apAvailable').textContent = '$' + ap.available_usd.toFixed(0);
            document.getElementById('apPositions').textContent =
                ap.positions.length + '/' + ap.max_positions;
            // Render activity log
            const activityEl = document.getElementById('apActivity');
            if (activityEl && ap.log) {
                activityEl.innerHTML = renderApLog(ap.log);
            }
        } else {
            statusEl.textContent = 'OFF';
            statusEl.style.background = 'var(--border)';
            statusEl.style.color = 'var(--text-muted)';
            onEl.style.display = 'none';
            offEl.style.display = 'flex';
        }
    } catch(e) {}
}

async function startAutopilot() {
    const amount = parseFloat(document.getElementById('apAmount').value);
    const slots = parseInt(document.getElementById('apSlots').value);
    if (!amount || amount < 10) {
        alert('Minimum $10 for autopilot');
        return;
    }
    try {
        const resp = await fetch('/api/autopilot', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({action: 'start', amount_usd: amount, max_positions: slots}),
        });
        if (resp.ok) fetchAutopilotStatus();
    } catch(e) {}
}

async function stopAutopilot() {
    if (!confirm('Stop autopilot? Existing positions will be closed by AI on next cycle.')) return;
    try {
        const resp = await fetch('/api/autopilot', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({action: 'stop'}),
        });
        if (resp.ok) fetchAutopilotStatus();
    } catch(e) {}
}

fetchAutopilotStatus();
setInterval(fetchAutopilotStatus, 10000);

// ═══════════════════════════════════════
// Logs Drawer
// ═══════════════════════════════════════
let logsAutoRefresh = null;

function toggleLogsDrawer() {
    let drawer = document.getElementById('logsDrawer');
    if (!drawer) {
        // Create drawer on first click
        drawer = document.createElement('div');
        drawer.id = 'logsDrawer';
        drawer.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:12px 16px;border-bottom:1px solid var(--border);background:var(--surface);">
                <span style="font-weight:700;font-size:14px;">Bot Logs</span>
                <div style="display:flex;gap:10px;align-items:center;">
                    <span id="logsFile" style="font-size:11px;color:var(--text-muted);"></span>
                    <button onclick="fetchLogs()" style="background:var(--accent);color:#fff;border:none;padding:4px 12px;border-radius:6px;cursor:pointer;font-size:12px;">Refresh</button>
                    <button onclick="toggleLogsDrawer()" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:18px;">&#10005;</button>
                </div>
            </div>
            <pre id="logsContent" style="margin:0;padding:12px 16px;font-size:11px;line-height:1.6;color:var(--text-secondary);overflow-y:auto;flex:1;font-family:monospace;white-space:pre-wrap;word-break:break-all;"></pre>
        `;
        Object.assign(drawer.style, {
            position: 'fixed', bottom: '0', left: '0', right: '0',
            height: '40vh', background: 'var(--bg)', borderTop: '2px solid var(--accent)',
            display: 'flex', flexDirection: 'column', zIndex: '1000',
            transition: 'transform 0.3s ease', boxShadow: '0 -4px 20px rgba(0,0,0,0.4)',
        });
        document.body.appendChild(drawer);
        fetchLogs();
        logsAutoRefresh = setInterval(fetchLogs, 10000);
        return;
    }

    if (drawer.style.display === 'none') {
        drawer.style.display = 'flex';
        fetchLogs();
        logsAutoRefresh = setInterval(fetchLogs, 10000);
    } else {
        drawer.style.display = 'none';
        if (logsAutoRefresh) { clearInterval(logsAutoRefresh); logsAutoRefresh = null; }
    }
}

async function fetchLogs() {
    try {
        const resp = await fetch('/api/logs?lines=200');
        if (!resp.ok) return;
        const data = await resp.json();
        const el = document.getElementById('logsContent');
        if (!el) return;

        // Color-code log lines
        el.innerHTML = data.lines.map(line => {
            if (line.includes('[ERROR]') || line.includes('Error') || line.includes('failed'))
                return `<span style="color:var(--red);">${escapeHtml(line)}</span>`;
            if (line.includes('CLOSED') || line.includes('STOP-LOSS') || line.includes('TRAILING'))
                return `<span style="color:#f80;">${escapeHtml(line)}</span>`;
            if (line.includes('BUY') || line.includes('RE-ENTRY') || line.includes('TREND SCANNER'))
                return `<span style="color:var(--green);">${escapeHtml(line)}</span>`;
            if (line.includes('====') || line.includes('Trading cycle'))
                return `<span style="color:var(--accent);">${escapeHtml(line)}</span>`;
            return escapeHtml(line);
        }).join('\n');

        // Auto-scroll to bottom
        el.scrollTop = el.scrollHeight;

        const fileEl = document.getElementById('logsFile');
        if (fileEl && data.file) fileEl.textContent = data.file;
    } catch(e) {
        const el = document.getElementById('logsContent');
        if (el) el.textContent = 'Failed to load logs.';
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
</script>
{% endblock %}
