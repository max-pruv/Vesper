{% extends "base.html" %}
{% block title %}Vesper{% endblock %}
{% block head %}
<script src="https://unpkg.com/lightweight-charts@4/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
{% endblock %}
{% block body %}

<!-- Scrolling Ticker Bar -->
<div class="ticker-bar" id="tickerBar">
    <div class="ticker-track" id="tickerTrack">
        <span class="ticker-item"><span class="ticker-name">Loading prices...</span></span>
    </div>
</div>

<div class="nav">
    <span class="nav-logo">vesper</span>
    <div class="nav-links">
        <a class="nav-link active" href="/dashboard">Dashboard</a>
        <a class="nav-link" href="/settings">Settings</a>
        <a class="nav-link" href="/logout">Log out</a>
    </div>
</div>

<div class="page-wrapper">
<div class="container">

    {% if not has_api_keys %}
    <div class="alert" style="background:rgba(255,255,255,0.04);color:var(--text-secondary);border:1px solid var(--border);border-radius:12px;">
        Connect your Coinbase API keys to start trading.
        <a href="/settings" style="margin-left:8px;font-weight:600;">Setup</a>
    </div>
    {% endif %}

    <!-- Portfolio Header + Stats -->
    <div style="display:flex;justify-content:space-between;align-items:flex-end;margin-bottom:32px;flex-wrap:wrap;gap:16px;">
        <div>
            <div style="font-size:14px;color:var(--text-muted);margin-bottom:4px;">Portfolio Value</div>
            <div style="font-size:48px;font-weight:700;letter-spacing:-2px;line-height:1;" id="portfolioValue">${{ "%.2f"|format(cash) }}</div>
            <div style="display:flex;align-items:center;gap:8px;margin-top:8px;">
                <span id="totalPnl" class="{{ 'positive' if total_pnl >= 0 else 'negative' }}" style="font-size:16px;font-weight:600;">
                    ${{ "%+.2f"|format(total_pnl) }} ({{ "%+.2f"|format(total_pnl_pct) }}%)
                </span>
                <span style="font-size:13px;color:var(--text-muted);">all time</span>
            </div>
        </div>
        <div style="display:flex;gap:24px;">
            <div style="text-align:center;">
                <div style="font-size:20px;font-weight:700;" id="statWinRate">{{ "%.0f"|format(win_rate) }}%</div>
                <div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;">Win Rate</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:20px;font-weight:700;" id="statTrades">{{ total_trades }}</div>
                <div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;">Trades</div>
            </div>
            <div style="text-align:center;">
                <div style="font-size:20px;font-weight:700;" id="statOpen">0</div>
                <div style="font-size:11px;color:var(--text-muted);text-transform:uppercase;">Open</div>
            </div>
        </div>
    </div>

    <!-- Real-Time Price Chart -->
    <div class="card" style="padding:0;overflow:hidden;">
        <div style="display:flex;justify-content:space-between;align-items:center;padding:16px 20px 0;flex-wrap:wrap;gap:8px;">
            <div class="chart-tabs" style="padding:0;">
                {% set symbols = user.symbols.split(',') %}
                {% for sym in symbols %}
                <button class="chart-tab {{ 'active' if loop.first }}"
                        data-symbol="{{ sym.strip() }}"
                        onclick="switchChart(this, '{{ sym.strip() }}')">
                    {{ sym.strip().split('/')[0] }}
                </button>
                {% endfor %}
            </div>
            <div class="chart-tabs" style="padding:0;">
                <button class="chart-tab" data-tf="15m" onclick="switchTimeframe(this, '15m')">15m</button>
                <button class="chart-tab active" data-tf="1h" onclick="switchTimeframe(this, '1h')">1H</button>
                <button class="chart-tab" data-tf="4h" onclick="switchTimeframe(this, '4h')">4H</button>
                <button class="chart-tab" data-tf="1d" onclick="switchTimeframe(this, '1d')">1D</button>
            </div>
        </div>
        <div id="priceChart" style="height:400px;"></div>
    </div>

    <!-- Active Bets -->
    <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
            <div class="card-title" style="margin-bottom:0;">Active Bets</div>
            <button class="btn btn-accent btn-sm" onclick="openTradeModal()">+ New Bet</button>
        </div>
        <div id="activeBets">
            <div class="empty-state">
                <div class="empty-state-icon">~</div>
                No active bets — pick a strategy below to start
            </div>
        </div>
    </div>

    <!-- Strategy Catalog -->
    <div class="card">
        <div class="card-title">Strategies</div>
        <div class="strategy-grid">
            {% for s in strategies %}
            <div class="strategy-card" onclick="openTradeModal('{{ s.id }}')">
                <div class="strategy-header">
                    <div>
                        <span class="strategy-icon">{{ s.icon }}</span>
                        <span class="strategy-name">{{ s.name }}</span>
                    </div>
                    <span class="risk-badge risk-{{ s.risk_level }}">{{ s.risk_level }}</span>
                </div>
                <div class="strategy-desc">{{ s.description }}</div>
                <div class="strategy-meta">
                    <div>
                        <div class="strategy-meta-label">Timeframe</div>
                        <div class="strategy-meta-value">{{ s.timeframe }}</div>
                    </div>
                    {% if s.min_return_pct > 0 or s.max_return_pct > 0 %}
                    <div>
                        <div class="strategy-meta-label">Expected</div>
                        <div class="strategy-meta-value positive">+{{ s.min_return_pct }}% to +{{ s.max_return_pct }}%</div>
                    </div>
                    {% endif %}
                    {% if s.default_stop_loss_pct > 0 %}
                    <div>
                        <div class="strategy-meta-label">Stop-Loss</div>
                        <div class="strategy-meta-value negative">-{{ s.default_stop_loss_pct }}%</div>
                    </div>
                    {% endif %}
                    <div>
                        <div class="strategy-meta-label">Mode</div>
                        <div class="strategy-meta-value">{{ s.default_mode | replace('_', ' ') | title }}</div>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>

    <!-- Cumulative P&L Chart -->
    <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
            <div class="card-title" style="margin-bottom:0;">Profit & Loss</div>
            <div style="display:flex;gap:12px;font-size:13px;">
                <span style="color:var(--text-muted);">Realized: <span id="pnlRealized" style="font-weight:600;">${{ "%+.2f"|format(total_pnl) }}</span></span>
                <span style="color:var(--text-muted);">Unrealized: <span id="pnlUnrealized" style="font-weight:600;">$0.00</span></span>
            </div>
        </div>
        <div style="height:220px;">
            <canvas id="pnlChart"></canvas>
        </div>
    </div>

    <!-- Trade History -->
    <div class="card">
        <div class="card-title">Trade History</div>
        {% if trades %}
        <table>
            <thead><tr>
                <th>Asset</th><th>Strategy</th><th>Entry</th><th>Exit</th>
                <th>Return</th><th>Time</th>
            </tr></thead>
            <tbody>
                {% for t in trades %}
                <tr>
                    <td style="font-weight:600;">{{ t.symbol.split('/')[0] }}</td>
                    <td style="font-size:12px;color:var(--text-secondary);">{{ t.reason }}</td>
                    <td>${{ "{:,.2f}".format(t.entry_price) }}</td>
                    <td>${{ "{:,.2f}".format(t.exit_price) }}</td>
                    <td>
                        <span class="{{ 'positive' if t.pnl_usd >= 0 else 'negative' }}" style="font-weight:600;">
                            ${{ "%+.2f"|format(t.pnl_usd) }}
                        </span>
                        <span style="color:var(--text-muted);font-size:12px;margin-left:4px;">
                            {{ "%+.1f"|format(t.pnl_pct) }}%
                        </span>
                    </td>
                    <td style="color:var(--text-muted);">{{ t.exit_time }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        {% else %}
        <div class="empty-state">
            <div class="empty-state-icon">~</div>
            No trades yet
        </div>
        {% endif %}
    </div>

</div>
</div>

<!-- Trade Modal -->
<div class="modal-overlay" id="tradeModal">
    <div class="modal">
        <button class="modal-close" onclick="closeTradeModal()">&times;</button>
        <div class="modal-title" id="modalTitle">New Bet</div>

        <div class="input-group">
            <label class="input-label">Strategy</label>
            <select class="input" id="modalStrategy" onchange="updateModalDefaults()">
                {% for s in strategies %}
                <option value="{{ s.id }}"
                        data-sl="{{ s.default_stop_loss_pct }}"
                        data-tpmin="{{ s.min_return_pct }}"
                        data-tpmax="{{ s.max_return_pct }}"
                        data-mode="{{ s.default_mode }}"
                        data-desc="{{ s.description }}">
                    {{ s.icon }} {{ s.name }} — {{ s.timeframe }}
                </option>
                {% endfor %}
            </select>
        </div>

        <!-- Strategy Callout -->
        <div class="strategy-callout" id="strategyCallout">
            <div class="strategy-callout-title">How it works</div>
            <div id="strategyCalloutText">Select a strategy to see details.</div>
        </div>

        <div class="input-group">
            <label class="input-label">Asset</label>
            <select class="input" id="modalSymbol">
                {% set symbols = user.symbols.split(',') %}
                {% for sym in symbols %}
                <option value="{{ sym.strip() }}">{{ sym.strip() }}</option>
                {% endfor %}
            </select>
        </div>

        <!-- Paper / Real Toggle -->
        <div class="input-group">
            <label class="input-label">Trade Type</label>
            <div class="mode-toggle">
                <button type="button" class="mode-toggle-btn active" id="modePaper"
                        onclick="setTradeMode('paper')">Paper</button>
                <button type="button" class="mode-toggle-btn" id="modeReal"
                        onclick="setTradeMode('real')">Real</button>
            </div>
        </div>

        <!-- One-Off / Continuous Toggle -->
        <div class="input-group">
            <label class="input-label">Bet Mode</label>
            <div class="mode-toggle">
                <button type="button" class="mode-toggle-btn active" id="modeOneOff"
                        onclick="setBetMode('one_off')">One-Off</button>
                <button type="button" class="mode-toggle-btn" id="modeContinuous"
                        onclick="setBetMode('continuous')">Continuous</button>
            </div>
        </div>

        <div class="input-group">
            <label class="input-label">Position Size ($)</label>
            <input type="number" class="input" id="modalAmount" value="50" min="1" step="1">
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;">
            <div class="input-group">
                <label class="input-label tooltip-wrap">
                    Stop-Loss %
                    <span class="tooltip-icon">?</span>
                    <span class="tooltip-text">If the price drops by this %, your position auto-closes to limit losses.</span>
                </label>
                <input type="number" class="input" id="modalSL" value="2" min="0.1" step="0.1">
            </div>
            <div class="input-group">
                <label class="input-label tooltip-wrap">
                    TP Min %
                    <span class="tooltip-icon">?</span>
                    <span class="tooltip-text">Minimum take-profit target. The bot may start closing here for partial gains.</span>
                </label>
                <input type="number" class="input" id="modalTPMin" value="1.5" min="0.1" step="0.1">
            </div>
            <div class="input-group">
                <label class="input-label tooltip-wrap">
                    TP Max %
                    <span class="tooltip-icon">?</span>
                    <span class="tooltip-text">Maximum take-profit. Position auto-closes when the price reaches this gain.</span>
                </label>
                <input type="number" class="input" id="modalTPMax" value="5" min="0.1" step="0.1">
            </div>
        </div>

        <div style="display:flex; justify-content:space-between; padding:10px 0; margin-top:4px; border-top:1px solid #222;">
            <span style="color:var(--red); font-weight:600;" id="maxLossDisplay">Max Loss: -$1.00</span>
            <span style="color:var(--text-muted); font-weight:600;" id="feeDisplay">Fee: ~$0.30</span>
            <span style="color:var(--green); font-weight:600;" id="maxWinDisplay">Max Win: +$2.50</span>
        </div>

        <div id="modalError" class="alert alert-error" style="display:none;"></div>
        <div id="modalSuccess" class="alert alert-success" style="display:none;"></div>

        <button class="btn btn-accent btn-full" id="placeBetBtn" onclick="placeBet()" style="margin-top:8px;">
            Place Bet
        </button>
    </div>
</div>

<script>
// ═══════════════════════════════════════
// State
// ═══════════════════════════════════════
let currentSymbol = '{{ user.symbols.split(",")[0].strip() }}';
let currentTimeframe = '1h';
let currentBetMode = 'one_off';
let currentTradeMode = 'paper';
let chart, candleSeries;
// Track previous P&L values for flash animations
let prevPnlMap = {};
// Track known position IDs for detecting new cards
let knownPositionIds = new Set();

// ═══════════════════════════════════════
// Ticker Bar (refresh every 5s)
// ═══════════════════════════════════════
async function updateTicker() {
    try {
        const resp = await fetch('/api/ticker');
        if (!resp.ok) return;
        const data = await resp.json();
        const track = document.getElementById('tickerTrack');
        let html = '';
        data.forEach(d => {
            const cls = d.change_pct >= 0 ? 'positive' : 'negative';
            const arrow = d.change_pct >= 0 ? '\u25B2' : '\u25BC';
            const price = d.price >= 1 ? d.price.toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2}) : d.price.toFixed(4);
            html += `<span class="ticker-item">
                <span class="ticker-name">${d.name}</span>
                <span class="ticker-price">$${price}</span>
                <span class="ticker-change ${cls}">${arrow} ${d.change_pct.toFixed(2)}%</span>
            </span>`;
        });
        // Duplicate for seamless loop
        track.innerHTML = html + html;
    } catch(e) {}
}
updateTicker();
setInterval(updateTicker, 5000);

// ═══════════════════════════════════════
// Price Chart (TradingView Lightweight, refresh every 10s)
// ═══════════════════════════════════════
function initChart() {
    const container = document.getElementById('priceChart');
    chart = LightweightCharts.createChart(container, {
        layout: { background: { color: '#111111' }, textColor: '#9ca3af' },
        grid: { vertLines: { color: '#1a1a1a' }, horzLines: { color: '#1a1a1a' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderColor: '#1a1a1a' },
        timeScale: { borderColor: '#1a1a1a', timeVisible: true },
        width: container.clientWidth,
        height: 400,
    });
    candleSeries = chart.addCandlestickSeries({
        upColor: '#00dc5a', downColor: '#ff3b30',
        borderUpColor: '#00dc5a', borderDownColor: '#ff3b30',
        wickUpColor: '#00dc5a', wickDownColor: '#ff3b30',
    });
    // Responsive
    new ResizeObserver(() => {
        chart.applyOptions({ width: container.clientWidth });
    }).observe(container);
}

async function loadChart(symbol, timeframe) {
    try {
        const safeSym = symbol.replace('/', '-');
        const resp = await fetch(`/api/chart/${safeSym}?timeframe=${timeframe}`);
        if (!resp.ok) return;
        const data = await resp.json();
        if (data.length > 0) {
            candleSeries.setData(data);
            chart.timeScale().fitContent();
        }
    } catch(e) {}
}

function switchChart(btn, symbol) {
    document.querySelectorAll('.chart-tab[data-symbol]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentSymbol = symbol;
    loadChart(symbol, currentTimeframe);
}

function switchTimeframe(btn, tf) {
    document.querySelectorAll('.chart-tab[data-tf]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentTimeframe = tf;
    loadChart(currentSymbol, tf);
}

initChart();
loadChart(currentSymbol, currentTimeframe);
// Refresh chart every 10s
setInterval(() => loadChart(currentSymbol, currentTimeframe), 10000);

// ═══════════════════════════════════════
// Active Bets — Full Dynamic Rendering (every 3s)
// ═══════════════════════════════════════
function formatPrice(price) {
    if (price >= 1) return price.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
    return price.toFixed(4);
}

function renderBetCard(p, isNew) {
    const pnlCls = p.pnl_usd >= 0 ? 'positive' : 'negative';
    const pnlSign = p.pnl_usd >= 0 ? '+' : '';
    const pctSign = p.pnl_pct >= 0 ? '+' : '';
    const rr = p.max_loss > 0 ? (p.max_win / p.max_loss) : 0;
    const rrCls = rr >= 2 ? 'positive' : rr >= 1 ? 'neutral' : 'negative';
    const progressPct = Math.max(0, Math.min(100, p.progress));
    const progressColor = p.pnl_usd >= 0 ? 'var(--green)' : 'var(--red)';
    const betMode = p.bet_mode || 'one_off';
    const tradeMode = p.trade_mode || 'paper';
    const modeCls = betMode === 'continuous' ? 'continuous' : 'one_off';

    // Flash animation class
    let flashClass = '';
    const prevPnl = prevPnlMap[p.id];
    if (prevPnl !== undefined && prevPnl !== p.pnl_usd) {
        flashClass = p.pnl_usd > prevPnl ? 'pnl-flash-positive' : 'pnl-flash-negative';
    }

    const entryDate = p.entry_time ? new Date(p.entry_time * 1000).toLocaleDateString('en', {month:'2-digit', day:'2-digit'}) + ' ' + new Date(p.entry_time * 1000).toLocaleTimeString('en', {hour:'2-digit', minute:'2-digit', hour12:false}) : '';

    return `<div class="bet-card ${isNew ? 'new-card' : ''} ${flashClass}" data-pid="${p.id}">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;">
            <div>
                <div style="font-size:16px;font-weight:700;">${p.name || p.symbol.split('/')[0]}</div>
                <div style="display:flex;gap:6px;margin-top:4px;">
                    <span class="mode-badge mode-${modeCls}">${betMode.replace('_', ' ')}</span>
                    <span class="mode-badge trade-mode-${tradeMode}">${tradeMode}</span>
                </div>
            </div>
            <div style="text-align:right;">
                <div class="bet-pnl ${pnlCls}">$${pnlSign}${p.pnl_usd.toFixed(2)}</div>
                <div style="font-size:12px;color:var(--text-muted);">${pctSign}${p.pnl_pct.toFixed(2)}%</div>
            </div>
        </div>
        <!-- Current Price (live) -->
        <div style="margin-top:8px;display:flex;align-items:center;gap:8px;">
            <span class="bet-current-price"><span class="live-dot"></span> Now $${formatPrice(p.current_price)}</span>
            <span style="font-size:12px;color:var(--text-muted);">${p.current_price >= p.entry_price ? '\u25B2' : '\u25BC'} ${Math.abs(p.pnl_pct).toFixed(2)}% from entry</span>
        </div>
        <!-- P/L View -->
        <div class="bet-pl-row">
            <div class="bet-pl-item">
                <span class="bet-pl-label">Max Loss</span>
                <span class="bet-pl-value" style="color:var(--red);">-$${p.max_loss.toFixed(2)}</span>
            </div>
            <div class="bet-pl-item">
                <span class="bet-pl-label">Fee</span>
                <span class="bet-pl-value" style="color:var(--text-muted);">~$${(p.est_fee || 0).toFixed(2)}</span>
            </div>
            <div class="bet-pl-item">
                <span class="bet-pl-label">Max Win</span>
                <span class="bet-pl-value" style="color:var(--green);">+$${p.max_win.toFixed(2)}</span>
            </div>
            <div class="bet-pl-item">
                <span class="bet-pl-label">R:R</span>
                <span class="bet-pl-value bet-rr ${rrCls}">1:${rr.toFixed(1)}</span>
            </div>
        </div>
        <div style="display:flex;gap:16px;margin-top:8px;font-size:13px;color:var(--text-secondary);">
            <span>Entry $${formatPrice(p.entry_price)}</span>
            <span>Size $${p.cost_usd.toFixed(2)}</span>
            <span style="color:var(--text-muted);">${entryDate}</span>
        </div>
        <div class="bet-progress">
            <div class="bet-progress-fill" style="width:${progressPct}%;background:${progressColor};"></div>
        </div>
        <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text-muted);margin-top:4px;">
            <span>SL $${formatPrice(p.stop_loss)}</span>
            <span>TP $${formatPrice(p.tp_min)} &ndash; $${formatPrice(p.tp_max)}</span>
        </div>
        <button class="btn btn-outline btn-sm" style="width:100%;margin-top:12px;"
                onclick="closeTrade('${p.id}')">Close Position</button>
    </div>`;
}

async function updatePositions() {
    try {
        const resp = await fetch('/api/positions');
        if (!resp.ok) return;
        const positions = await resp.json();
        const container = document.getElementById('activeBets');

        if (positions.length === 0) {
            container.innerHTML = `<div class="empty-state">
                <div class="empty-state-icon">~</div>
                No active bets — pick a strategy below to start
            </div>`;
            knownPositionIds.clear();
            prevPnlMap = {};
            return;
        }

        // Build new position ID set
        const newIds = new Set(positions.map(p => p.id));

        // Render all cards
        let html = '<div class="bet-grid">';
        positions.forEach(p => {
            const isNew = !knownPositionIds.has(p.id);
            html += renderBetCard(p, isNew);
        });
        html += '</div>';
        container.innerHTML = html;

        // Update tracking state
        positions.forEach(p => { prevPnlMap[p.id] = p.pnl_usd; });
        // Clean up removed positions from prevPnlMap
        Object.keys(prevPnlMap).forEach(id => {
            if (!newIds.has(id)) delete prevPnlMap[id];
        });
        knownPositionIds = newIds;
    } catch(e) {}
}
updatePositions();
setInterval(updatePositions, 3000);

// ═══════════════════════════════════════
// Trade Modal
// ═══════════════════════════════════════
function openTradeModal(strategyId) {
    document.getElementById('tradeModal').classList.add('active');
    document.getElementById('modalError').style.display = 'none';
    document.getElementById('modalSuccess').style.display = 'none';
    if (strategyId) {
        document.getElementById('modalStrategy').value = strategyId;
    }
    updateModalDefaults();
    updateMaxWinLoss();
}

function closeTradeModal() {
    document.getElementById('tradeModal').classList.remove('active');
}

function updateModalDefaults() {
    const sel = document.getElementById('modalStrategy');
    const opt = sel.options[sel.selectedIndex];
    document.getElementById('modalSL').value = opt.dataset.sl || 2;
    document.getElementById('modalTPMin').value = opt.dataset.tpmin || 1.5;
    document.getElementById('modalTPMax').value = opt.dataset.tpmax || 5;
    const mode = opt.dataset.mode || 'one_off';
    setBetMode(mode);
    // Update strategy callout
    const desc = opt.dataset.desc || '';
    document.getElementById('strategyCalloutText').textContent = desc || 'Select a strategy to see details.';
    updateMaxWinLoss();
}

// Set initial callout on page load
(function() {
    const sel = document.getElementById('modalStrategy');
    if (sel && sel.options.length > 0) {
        const opt = sel.options[sel.selectedIndex];
        document.getElementById('strategyCalloutText').textContent = opt.dataset.desc || '';
    }
})();

function updateMaxWinLoss() {
    const amount = parseFloat(document.getElementById('modalAmount').value) || 0;
    const sl = parseFloat(document.getElementById('modalSL').value) || 0;
    const tpMax = parseFloat(document.getElementById('modalTPMax').value) || 0;
    // Coinbase Advanced taker fee: ~0.60% per trade (entry + exit = ~1.2% round-trip)
    const feeRate = 0.006;
    const totalFee = amount * feeRate * 2;
    // Net forecasts: factor in round-trip fees
    const maxLoss = amount * (sl / 100) + totalFee;
    const maxWin = Math.max(0, amount * (tpMax / 100) - totalFee);
    document.getElementById('maxLossDisplay').textContent = 'Max Loss: -$' + maxLoss.toFixed(2);
    document.getElementById('feeDisplay').textContent = 'Fee: ~$' + totalFee.toFixed(2);
    document.getElementById('maxWinDisplay').textContent = 'Net Win: +$' + maxWin.toFixed(2);
}

['modalAmount', 'modalSL', 'modalTPMax'].forEach(id => {
    document.getElementById(id).addEventListener('input', updateMaxWinLoss);
});

function setTradeMode(mode) {
    currentTradeMode = mode;
    document.getElementById('modePaper').classList.toggle('active', mode === 'paper');
    document.getElementById('modeReal').classList.toggle('active', mode === 'real');
}

function setBetMode(mode) {
    currentBetMode = mode;
    document.getElementById('modeOneOff').classList.toggle('active', mode === 'one_off');
    document.getElementById('modeContinuous').classList.toggle('active', mode === 'continuous');
}

async function placeBet() {
    const btn = document.getElementById('placeBetBtn');
    const errEl = document.getElementById('modalError');
    const okEl = document.getElementById('modalSuccess');
    errEl.style.display = 'none';
    okEl.style.display = 'none';
    btn.disabled = true;
    btn.textContent = 'Placing...';

    try {
        const resp = await fetch('/api/open-trade', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                symbol: document.getElementById('modalSymbol').value,
                strategy_id: document.getElementById('modalStrategy').value,
                amount_usd: parseFloat(document.getElementById('modalAmount').value),
                stop_loss_pct: parseFloat(document.getElementById('modalSL').value),
                tp_min_pct: parseFloat(document.getElementById('modalTPMin').value),
                tp_max_pct: parseFloat(document.getElementById('modalTPMax').value),
                bet_mode: currentBetMode,
                trade_mode: currentTradeMode,
            }),
        });
        const data = await resp.json();
        if (data.ok) {
            okEl.textContent = `Bet placed at $${data.entry_price.toLocaleString()}`;
            okEl.style.display = 'block';
            // Immediately refresh positions & portfolio — no page reload needed
            updatePositions();
            updatePortfolioStats();
            setTimeout(closeTradeModal, 1200);
        } else {
            errEl.textContent = data.error || 'Failed to place bet';
            errEl.style.display = 'block';
        }
    } catch(e) {
        errEl.textContent = 'Network error';
        errEl.style.display = 'block';
    }
    btn.disabled = false;
    btn.textContent = 'Place Bet';
}

async function closeTrade(positionId) {
    if (!confirm('Close this position at market price?')) return;
    try {
        const resp = await fetch('/api/close-trade', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ position_id: positionId }),
        });
        const data = await resp.json();
        if (data.ok) {
            // Immediately refresh — no page reload needed
            updatePositions();
            updatePortfolioStats();
        } else {
            alert(data.error || 'Failed to close');
        }
    } catch(e) {
        alert('Network error');
    }
}

// Close modal on overlay click
document.getElementById('tradeModal').addEventListener('click', function(e) {
    if (e.target === this) closeTradeModal();
});

// ═══════════════════════════════════════
// Live Portfolio Stats + P&L Chart (every 5s)
// ═══════════════════════════════════════
let pnlChart = null;

function initPnlChart(history) {
    const ctx = document.getElementById('pnlChart');
    const labels = history.map(d => d.time ? new Date(d.time * 1000).toLocaleDateString('en', {month:'short', day:'numeric'}) : '');
    const values = history.map(d => d.pnl);
    const lastVal = values.length > 0 ? values[values.length - 1] : 0;
    const positive = lastVal >= 0;

    // Bar colors: green for cumulative profit, red when dipping below zero
    const barColors = values.map(v => v >= 0 ? 'rgba(0,220,90,0.7)' : 'rgba(255,59,48,0.7)');

    pnlChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: barColors,
                borderRadius: 3,
                barPercentage: 0.8,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                tooltip: {
                    mode: 'index', intersect: false,
                    backgroundColor: '#1a1a1a', borderColor: '#2a2a2a', borderWidth: 1,
                    titleColor: '#9ca3af', bodyColor: '#fff', bodyFont: { weight: '600' },
                    padding: 12, cornerRadius: 8,
                    callbacks: { label: ctx => '$' + ctx.parsed.y.toFixed(2) + ' cumulative P&L' }
                }
            },
            scales: {
                x: { display: true, ticks: { color: '#555', font: { size: 10 } }, grid: { display: false } },
                y: {
                    display: true,
                    ticks: { color: '#555', font: { size: 10 }, callback: v => '$' + v },
                    grid: { color: '#1a1a1a' },
                }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
        }
    });
}

function updatePnlChart(history) {
    if (!pnlChart) {
        initPnlChart(history);
        return;
    }
    pnlChart.data.labels = history.map(d => d.time ? new Date(d.time * 1000).toLocaleDateString('en', {month:'short', day:'numeric'}) : '');
    pnlChart.data.datasets[0].data = history.map(d => d.pnl);
    pnlChart.data.datasets[0].backgroundColor = history.map(d => d.pnl >= 0 ? 'rgba(0,220,90,0.7)' : 'rgba(255,59,48,0.7)');
    pnlChart.update('none');
}

async function updatePortfolioStats() {
    try {
        const resp = await fetch('/api/portfolio-stats');
        if (!resp.ok) return;
        const s = await resp.json();

        // Portfolio value (cash + positions + unrealized P&L)
        document.getElementById('portfolioValue').textContent = '$' + s.portfolio_value.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});

        // Total P&L
        const pnlEl = document.getElementById('totalPnl');
        const sign = s.total_pnl >= 0 ? '+' : '';
        pnlEl.textContent = '$' + sign + s.total_pnl.toFixed(2) + ' (' + sign + s.total_pnl_pct.toFixed(2) + '%)';
        pnlEl.className = s.total_pnl >= 0 ? 'positive' : 'negative';

        // Stats
        document.getElementById('statWinRate').textContent = Math.round(s.win_rate) + '%';
        document.getElementById('statTrades').textContent = s.total_trades;
        document.getElementById('statOpen').textContent = s.open_count;

        // P&L breakdown
        const rSign = s.realized_pnl >= 0 ? '+' : '';
        const uSign = s.unrealized_pnl >= 0 ? '+' : '';
        document.getElementById('pnlRealized').textContent = '$' + rSign + s.realized_pnl.toFixed(2);
        document.getElementById('pnlRealized').style.color = s.realized_pnl >= 0 ? 'var(--green)' : 'var(--red)';
        document.getElementById('pnlUnrealized').textContent = '$' + uSign + s.unrealized_pnl.toFixed(2);
        document.getElementById('pnlUnrealized').style.color = s.unrealized_pnl >= 0 ? 'var(--green)' : 'var(--red)';

        // P&L chart
        if (s.pnl_history && s.pnl_history.length > 0) {
            updatePnlChart(s.pnl_history);
        }
    } catch(e) {}
}

// Initialize P&L chart from server-rendered data, then switch to live
const initialPnlData = {{ equity_curve|safe }};
if (initialPnlData.length > 1) {
    // Convert equity curve to cumulative P&L format
    const initial = initialPnlData[0].value;
    const pnlHistory = initialPnlData.slice(1).map(d => ({
        time: d.time,
        pnl: +(d.value - initial).toFixed(2),
    }));
    initPnlChart(pnlHistory);
} else {
    initPnlChart([]);
}

// Fetch live stats immediately and every 5s
updatePortfolioStats();
setInterval(updatePortfolioStats, 5000);
</script>
{% endblock %}
